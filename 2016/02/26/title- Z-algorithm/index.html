<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相比于字符串排序，字符串匹配理解起来就没那么容易了，而且实现其实也比较麻烦。这里我整理下最近学的三个字符串匹配算法。但是如果将三个算法放一篇里无疑是太长了。今天先来看看<strong>Z-algorithm</strong>。</p>
<blockquote>
<p>在<strong>Gusfield</strong>[1]一书中，Z算法也称为基本预处理（Fundamental pre-processing）。</p>
</blockquote>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>首先来定义需要解决的问题以及一些可能接下来常用的表示方式。</p>
<blockquote>
<p>字串搜寻算法（String searching algorithms，又译字符串搜索算法）又称字串比对算法（string matching algorithms）是一种搜索算法，是字串算法中的一类，用以试图在一长字符串或文章中，找出其是否包含某一个或多个字符串，以及其位置.[2]</p>
</blockquote>
<p>通常使用<strong>T</strong>来表示待匹配的文本字符串；<strong>P</strong>表示待匹配的字符；<strong>S</strong>表示待搜索的字符串。比如：<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%882.03.46.png" alt=""></p>
<p>那么<strong>P</strong>在<strong>T</strong>中出现，且出现次数为3，我们输出这三处匹配的位置。</p>
<blockquote>
<p>注意<strong>S</strong>和<strong>T</strong>虽然在多数情况下是一致的，但不能混淆，在Z算法中<strong>S</strong>就与<strong>T</strong>不一样。</p>
<p>虽然中文也能够进行字符串匹配，但是其算法完全不同，这里讨论的是英文字符串的匹配算法。</p>
</blockquote>
<h3 id="子串（Substring）"><a href="#子串（Substring）" class="headerlink" title="子串（Substring）"></a>子串（Substring）</h3><p>给定一个长度为<strong>m</strong>的字符串<strong>S</strong>，我们可以使用$S[i,j]$来表示其所有的子串，其中<strong>i</strong>与<strong>j</strong>分别表示其子串的开始和结束的字符位置。所以<strong>S</strong>也可以表示为：$S[0,m-1]$。</p>
<h3 id="前缀（Prefix）和后缀（Suffix）"><a href="#前缀（Prefix）和后缀（Suffix）" class="headerlink" title="前缀（Prefix）和后缀（Suffix）"></a>前缀（Prefix）和后缀（Suffix）</h3><p>为了简化在算法中的描述，我们定义两种特殊的子串，分别是前缀与后缀。<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%882.30.27.png" alt=""></p>
<p><em>定义</em>：所有形如$S[0,i]$的子串为前缀，其中$i \in (0, m-1)$。同样的所有形如$S[i,m-1]$的子串为前缀，其中$i \in (0, m-1)$</p>
<blockquote>
<p>这里我们采用的是较为严格的定义方式，即前缀与后缀非空且不能是字符串。</p>
</blockquote>
<h2 id="Z-algorithm"><a href="#Z-algorithm" class="headerlink" title="Z-algorithm"></a>Z-algorithm</h2><h3 id="Z值"><a href="#Z值" class="headerlink" title="Z值"></a>Z值</h3><p>在正式描述算法原理之前，需要先来定义一个Z算法会使用的特殊值：Z值。</p>
<p><em>定义</em>: $Z_i$ 是使得从<strong>i</strong>开始的子串（$S[i,Z_i]$）仍为<strong>S</strong> ($S[0,m-1]$)的前缀的最大的值.</p>
<p><em>举例</em>：<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%882.55.24.png" alt=""></p>
<blockquote>
<p>注意$Z_i$是由$Z_0$开始的，此时$Z_0 = |S| = 14$ 而在我们对前缀的定义中，前缀不能为字符串本身，所以这种情况忽略。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Z算法的实现分为三步：</p>
<ol>
<li>定义$S = P \$ T$；</li>
<li>计算<strong>S</strong>的所有<strong>$Z_i$</strong>值；</li>
<li>对于所有的<strong>i</strong>大于<strong>P</strong>的长度<strong>m</strong>，如果$Z_i = m$，那么<strong>i</strong>就是<strong>P</strong>在<strong>T</strong>中出现的位置。</li>
</ol>
<blockquote>
<p>步骤<code>1</code>中的<strong>\$</strong>是不出现在<strong>T</strong>与<strong>P</strong>中的特殊符号，与任何字符都不匹配。</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>我们要匹配的<strong>T</strong>与<strong>P</strong>如下：<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%883.14.58.png" alt=""></p>
<p>首先我们将组合$P \$ T$形成<strong>S</strong>字符串，并计算其$Z_i$值，如下：<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%883.15.10.png" alt=""></p>
<p>最后，如果$Z_i = m = 3$，那么 <strong>i</strong> 就是<strong>P</strong>在<strong>T</strong>中出现的位置。<br><img src="http://7xjz11.com1.z0.glb.clouddn.com/%E5%8D%9A%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-03%20%E4%B8%8B%E5%8D%883.15.34.png" alt=""><br>也就是$4$和$7$。</p>
<blockquote>
<p>本举例来自于<a href="http://www.utdallas.edu/~besp/demo/John2010/z-match.htm" target="_blank" rel="external">这里</a></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>步骤<code>1</code>将两个字符串组合的时间复杂度取决于数据类型，但最多不超过$O(m+n)$，而步骤<code>3</code>仅需遍历一边<strong>S</strong>，所需时间也是$O(m+n)$，所以Z算法的最终时间复杂度将取决于$Z_i$值计算的时间复杂度。</p>
<h2 id="参考及其他"><a href="#参考及其他" class="headerlink" title="参考及其他"></a>参考及其他</h2><p>[1]: <a href="http://ebooks.cambridge.org/chapter.jsf?bid=CBO9780511574931&amp;cid=CBO9780511574931A007" target="_blank" rel="external">D. Gusfield, Algorithms on Strings, Trees, and Sequences:Computer Science and Computational Biology, pp.5-15.</a><br>[2]: <a href="https://zh.wikipedia.org/wiki/字串搜尋演算法" target="_blank" rel="external">字串搜寻算法 - 维基</a></p>
